include $(RULES)/configure/RULES.CreatedVars
include $(EPICS_BASE)/configure/RULES

# Generate c from st or stt.
# These rules are exactly like the ones in the seq module,
# only the dependency is not explicitly prefixed with ../,
# thus we can generate st and stt files.

%.i: %.st
	@echo "preprocessing $(<F)"
	@$(RM) $@
	$(PREPROCESS.cpp)

%.c: %.stt
	@echo "converting $(<F) "
	$(SNC) $(TARGET_SNCFLAGS) $(SNCFLAGS) $< -o $(@F).tmp
	$(MV) $(@F).tmp $@

# db file generation

RELEASE_DBSEARCHDIRS = $(RELEASE_DBFLAGS:-I%=%)

vpath %.db $(RELEASE_DBSEARCHDIRS) $(COMMON_DIR)
vpath %.vdb $(INSTALL_SHARE) $(RELEASE_DBSEARCHDIRS)
vpath %.template $(INSTALL_SHARE) $(RELEASE_DBSEARCHDIRS)

DBFLAGS += -I$(INSTALL_SHARE) $(RELEASE_DBFLAGS)

FLATDB_DBDPATH = $(filter-out -I,$(DBDFLAGS))
FLATDB_ENV = EPICS_DB_INCLUDE_PATH=`echo "$(DBFLAGS:-I%=%) $(filter-out -I,$(DBDFLAGS))" | tr ' ' ':'`

define FLATDB_COMMANDS
	@echo Flattening $(<F) to $(@F)
	@$(RM) $@
	# too bad flatdb doesn't return a usable exit code
	-$(FLATDB_ENV) $(FLATDB) $(FLATDB_FLAGS) -d $1 $< $(COMMON_DIR)/$@ $2
	# flatdb leaves behind comment lines which contain source paths;
	# this is bad for diff'ing results, so we remove them here
	$(PERL) -pi -e 's/^\#.*\n//' $(COMMON_DIR)/$@
endef

ifdef DBDNAME # if a common DBDNAME is defined, use it for flatdb
%.template: %.vdb $(COMMON_DIR)/$(DBDNAME)
	$(call FLATDB_COMMANDS,$(COMMON_DIR)/$(DBDNAME),| grep -vi warning)
$(COMMON_DIR)/%.db$(RAW): %.vdb $(COMMON_DIR)/$(DBDNAME)
	$(call FLATDB_COMMANDS,$(COMMON_DIR)/$(DBDNAME),| grep -vi warning)
else # no common dbd file, use target specific one
%.template: %.vdb $(COMMON_DIR)/%.dbd
	$(call FLATDB_COMMANDS,$(COMMON_DIR)/$*.dbd,| grep -vi warning)
$(COMMON_DIR)/%.db$(RAW): %.vdb $(COMMON_DIR)/%.dbd
	$(call FLATDB_COMMANDS,$(COMMON_DIR)/$*.dbd,| grep -vi warning)
endif

$(COMMON_DIR)/.vdct: .FORCE
	@echo "export $(FLATDB_ENV)" | sed 's|:\.\./|:|g' > $@

.FORCE:

build: $(COMMON_DIR)/.vdct

vpath %.sch
vpath %.sch . .. $(INSTALL_SHARE) $(RELEASE_DBSEARCHDIRS)

%.template: %.sch
	@echo Generating $@ from capfast schematic
	$(SCH2DB) $(SCH2DB_FLAGS) -f $< -o $@

$(COMMON_DIR)/%.db$(RAW)$(DEP): %.substitutions
	@$(RM) $@
	$(PERL) -e 'undef $$/; $$_=<>; @d=m/(?:^|})\s*file\s+([^{\s]*)\s*\{/g; print "$(COMMON_DIR)/$*.db$(RAW): @d\n";' $< > $@.tmp
	$(MV) $@.tmp $@

$(COMMON_DIR)/%.db$(RAW): %.substitutions
	@echo "Inflating database from $(<F)"
	@$(RM) $@
	$(MSI) $(DBFLAGS) -S$< $(TEMPLATE_FILENAME) > $@.tmp
	$(MV) $@.tmp $@

%.dbd$(DEP): %Include.dbd $(TOP)/configure/RELEASE
	-$(MKMF) -m $@ $(DBDDEPENDS_FLAGS) $*.dbd $<

ifeq ($(strip $(DB_OPT)),YES)
DBST_TARGETS = $(addprefix $(COMMON_DIR)/,$(notdir $(filter %.db, $(DB))))

ifdef DBDNAME
$(DBST_TARGETS): $(COMMON_DIR)/%.db: $(COMMON_DIR)/$(DBDNAME) $(COMMON_DIR)/%.db$(RAW)
	@echo "Optimizing database $(@F)"
	@$(RM) $@
	$(DBST) $^ -w0,,$@
else
$(DBST_TARGETS): $(COMMON_DIR)/%.db: $(COMMON_DIR)/%.dbd $(COMMON_DIR)/%.db$(RAW)
	@echo "Optimizing database $(@F)"
	@$(RM) $@
	$(DBST) $^ -w0,,$@
endif
endif

# Generate db files directly from Gadgets database.
# For this rule to work, the application must define
# the variable TOP_NAME, preferably in configure/CONFIG
$(COMMON_DIR)/%.db:
	@echo "Generating $(@F) from Gadgets"
	@$(RM) $@
	$(CREATE_DB) $(TOP_NAME) $(subst ., ,$*) > $@.tmp
	$(MV) $@.tmp $@

# GENERIC_INSTALL_RULE should be called with 3 or 4 arguments:
# $1 extension
# $2 description of file type
# $3 where to install
# $4 (optional) extra vpath dirs
define GENERIC_INSTALL_RULE
vpath %.$1 $(USR_VPATH) $(GENERIC_SRC_DIRS) $4 $(COMMON_DIR)
$3/%.$1: %.$1
	@echo "Installing $2 file $$(@F)"
	@$$(INSTALL) -d -m 644 $$< $$(@D)
endef

# Extra DB files

DB_EXTRA_TARGETS = $(DB_EXTRA:%=$(INSTALL_DB)/$(notdir %))

build: $(DB_EXTRA_TARGETS)

$(eval $(call GENERIC_INSTALL_RULE,acf,access control,$(INSTALL_DB)))
$(eval $(call GENERIC_INSTALL_RULE,req,request,$(INSTALL_DB)))
$(eval $(call GENERIC_INSTALL_RULE,proto,protocol,$(INSTALL_DB),$(RELEASE_DBSEARCHDIRS)))

# ETC (configuration) files

$(eval $(call GENERIC_INSTALL_RULE,req,request,$(INSTALL_ETC)))
$(eval $(call GENERIC_INSTALL_RULE,arch,archiver configuration,$(INSTALL_ETC)))
$(eval $(call GENERIC_INSTALL_RULE,caput,caput,$(INSTALL_ETC)))
$(eval $(call GENERIC_INSTALL_RULE,alh,alarm handler,$(INSTALL_ETC)))
$(eval $(call GENERIC_INSTALL_RULE,cmlogrc,cmlog configuration,$(INSTALL_ETC)))

INSTALL_ETCS += $(addprefix $(INSTALL_ETC)/,$(notdir $(ETC)))

build: $(INSTALL_ETCS)

# Display files

# ConvertRelease.pl from EPICS base should be modified to generate
# RELEASE_DLSEARCHDIRS. For the time being, specify it manually in a Makefile.
DL_SEARCHDIRS = $(USR_VPATH) $(GENERIC_SRC_DIRS) $(RELEASE_DLSEARCHDIRS) $(COMMON_DIR)
DL_INCLUDES = $(DL_SEARCHDIRS:%=-I %)

$(eval $(call GENERIC_INSTALL_RULE,edl,edm display,$(INSTALL_DL),$(RELEASE_DLSEARCHDIRS)))
$(eval $(call GENERIC_INSTALL_RULE,mfp,dm2k faceplate,$(INSTALL_DL),$(RELEASE_DLSEARCHDIRS)))
$(eval $(call GENERIC_INSTALL_RULE,gif,gif image,$(INSTALL_DL),$(RELEASE_DLSEARCHDIRS)))
$(eval $(call GENERIC_INSTALL_RULE,png,png image,$(INSTALL_DL),$(RELEASE_DLSEARCHDIRS)))
$(eval $(call GENERIC_INSTALL_RULE,jpg,jpg image,$(INSTALL_DL),$(RELEASE_DLSEARCHDIRS)))

vpath %.adl $(USR_VPATH) $(GENERIC_SRC_DIRS) $(RELEASE_DLSEARCHDIRS) $(COMMON_DIR)
$(INSTALL_DL)/%.adl: %.adl
	@echo "Installing dm2k display file $(@F)"
	sed 's/clr=35/clr="$$(DOMAIN)"/g' $< > $(COMMON_DIR)/$(<F).tmp
	$(MV) $(COMMON_DIR)/$(<F).tmp $(COMMON_DIR)/$(<F)
	$(INSTALL) -d -m 644 $(COMMON_DIR)/$(<F) $(@D)

INSTALL_DLS += $(addprefix $(INSTALL_DL)/,$(notdir $(DL)))

build: $(INSTALL_DLS)

$(COMMON_DIR)/%.mfp$(DEP): %.substitutions
	$(CREATE_PANEL) -M -type adl $< $@

$(COMMON_DIR)/%.edl$(DEP): %.substitutions
	$(CREATE_PANEL) -M -type edl $< $@

# Documentation generation rules

vpath %.pl $(USR_VPATH) $(GENERIC_SRC_DIRS) $(COMMON_DIR)
vpath %.pm $(USR_VPATH) $(GENERIC_SRC_DIRS) $(COMMON_DIR)
vpath %.txt $(USR_VPATH) $(GENERIC_SRC_DIRS) $(COMMON_DIR)

$(INSTALL_DOC)/%: $(COMMON_DIR)/%
	@echo "Installing doc $(@F)"
	@$(INSTALL) -d -m 644 $< $(INSTALL_DOC)

define TOUCH_DOC_DEPENDS
 if test ! -d $(INSTALL_LOCATION)/doc; then\
  $(MKDIR) $(INSTALL_LOCATION)/doc;\
 fi;\
 touch $(INSTALL_LOCATION)/doc/doc.depends
endef

%.html: %.txt
	$(MAKE_DOC_TXT) $< $@
	@$(TOUCH_DOC_DEPENDS)

%.txt: %.pl
	$(MAKE_DOC_PERL) $< $@
	@$(TOUCH_DOC_DEPENDS)

%.txt: %.pm
	$(MAKE_DOC_PERL) $< $@
	@$(TOUCH_DOC_DEPENDS)

include $(RULES)/configure/RULES_FOREIGN

# build: debug
# debug:
# 	@echo "DEBUG: VAR=$(VAR)"
# .PHONY: debug

.DELETE_ON_ERROR:
